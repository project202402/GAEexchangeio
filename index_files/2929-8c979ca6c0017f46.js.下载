(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2929],{80447:function(e,t,o){"use strict";var r=o(48834).Buffer,n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.map=t.array=t.rustEnum=t.str=t.vecU8=t.tagged=t.vec=t.bool=t.option=t.publicKey=t.i256=t.u256=t.i128=t.u128=t.i64=t.u64=t.struct=t.f64=t.f32=t.i32=t.u32=t.i16=t.u16=t.i8=t.u8=void 0;let s=o(83742),a=o(53619),i=n(o(62197));var u=o(83742);Object.defineProperty(t,"u8",{enumerable:!0,get:function(){return u.u8}}),Object.defineProperty(t,"i8",{enumerable:!0,get:function(){return u.s8}}),Object.defineProperty(t,"u16",{enumerable:!0,get:function(){return u.u16}}),Object.defineProperty(t,"i16",{enumerable:!0,get:function(){return u.s16}}),Object.defineProperty(t,"u32",{enumerable:!0,get:function(){return u.u32}}),Object.defineProperty(t,"i32",{enumerable:!0,get:function(){return u.s32}}),Object.defineProperty(t,"f32",{enumerable:!0,get:function(){return u.f32}}),Object.defineProperty(t,"f64",{enumerable:!0,get:function(){return u.f64}}),Object.defineProperty(t,"struct",{enumerable:!0,get:function(){return u.struct}});class c extends s.Layout{constructor(e,t,o){super(e,o),this.blob=(0,s.blob)(e),this.signed=t}decode(e,t=0){let o=new i.default(this.blob.decode(e,t),10,"le");return this.signed?o.fromTwos(8*this.span).clone():o}encode(e,t,o=0){return this.signed&&(e=e.toTwos(8*this.span)),this.blob.encode(e.toArrayLike(r,"le",this.span),t,o)}}function l(e){return new c(8,!1,e)}t.u64=l,t.i64=function(e){return new c(8,!0,e)},t.u128=function(e){return new c(16,!1,e)},t.i128=function(e){return new c(16,!0,e)},t.u256=function(e){return new c(32,!1,e)},t.i256=function(e){return new c(32,!0,e)};class d extends s.Layout{constructor(e,t,o,r){super(e.span,r),this.layout=e,this.decoder=t,this.encoder=o}decode(e,t){return this.decoder(this.layout.decode(e,t))}encode(e,t,o){return this.layout.encode(this.encoder(e),t,o)}getSpan(e,t){return this.layout.getSpan(e,t)}}t.publicKey=function(e){return new d((0,s.blob)(32),e=>new a.PublicKey(e),e=>e.toBuffer(),e)};class m extends s.Layout{constructor(e,t){super(-1,t),this.layout=e,this.discriminator=(0,s.u8)()}encode(e,t,o=0){return null==e?this.discriminator.encode(0,t,o):(this.discriminator.encode(1,t,o),this.layout.encode(e,t,o+1)+1)}decode(e,t=0){let o=this.discriminator.decode(e,t);if(0===o)return null;if(1===o)return this.layout.decode(e,t+1);throw Error("Invalid option "+this.property)}getSpan(e,t=0){let o=this.discriminator.decode(e,t);if(0===o)return 1;if(1===o)return this.layout.getSpan(e,t+1)+1;throw Error("Invalid option "+this.property)}}function h(e){if(0===e)return!1;if(1===e)return!0;throw Error("Invalid bool: "+e)}function f(e){return e?1:0}function p(e){let t=(0,s.u32)("length"),o=(0,s.struct)([t,(0,s.blob)((0,s.offset)(t,-t.span),"data")]);return new d(o,({data:e})=>e,e=>({data:e}),e)}t.option=function(e,t){return new m(e,t)},t.bool=function(e){return new d((0,s.u8)(),h,f,e)},t.vec=function(e,t){let o=(0,s.u32)("length"),r=(0,s.struct)([o,(0,s.seq)(e,(0,s.offset)(o,-o.span),"values")]);return new d(r,({values:e})=>e,e=>({values:e}),t)},t.tagged=function(e,t,o){let r=(0,s.struct)([l("tag"),t.replicate("data")]);return new d(r,function({tag:t,data:o}){if(!t.eq(e))throw Error("Invalid tag, expected: "+e.toString("hex")+", got: "+t.toString("hex"));return o},t=>({tag:e,data:t}),o)},t.vecU8=p,t.str=function(e){return new d(p(),e=>e.toString("utf-8"),e=>r.from(e,"utf-8"),e)},t.rustEnum=function(e,t,o){let r=(0,s.union)(null!=o?o:(0,s.u8)(),t);return e.forEach((e,t)=>r.addVariant(t,e,e.property)),r},t.array=function(e,t,o){let r=(0,s.struct)([(0,s.seq)(e,t,"values")]);return new d(r,({values:e})=>e,e=>({values:e}),o)};class g extends s.Layout{constructor(e,t,o){super(e.span+t.span,o),this.keyLayout=e,this.valueLayout=t}decode(e,t){t=t||0;let o=this.keyLayout.decode(e,t),r=this.valueLayout.decode(e,t+this.keyLayout.getSpan(e,t));return[o,r]}encode(e,t,o){o=o||0;let r=this.keyLayout.encode(e[0],t,o),n=this.valueLayout.encode(e[1],t,o+r);return r+n}getSpan(e,t){return this.keyLayout.getSpan(e,t)+this.valueLayout.getSpan(e,t)}}t.map=function(e,t,o){let r=(0,s.u32)("length"),n=(0,s.struct)([r,(0,s.seq)(new g(e,t),(0,s.offset)(r,-r.span),"values")]);return new d(n,({values:e})=>new Map(e),e=>({values:Array.from(e.entries())}),o)}},38339:function(e,t,o){var r=o(18166);e.exports=r("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},50649:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WORMHOLE_PROGRAM_ADDRESS=t.HASHFLOW_FEE_COLLECTOR_ADDRESS=t.HASHFLOW_PROGRAM_ADDRESS=t.SOLANA_PUBLIC_RPC_URL=void 0,t.SOLANA_PUBLIC_RPC_URL={localnet:"http://127.0.0.1:8899",devnet:"https://api.devnet.solana.com",mainnet:"https://api.mainnet-beta.solana.com"},t.HASHFLOW_PROGRAM_ADDRESS={localnet:"DPgrckoPuTDnRS5L4KdgR87iESVzWEzr17TZUF12ryQg",devnet:"HB3LQRRBZqZWkYXhFgrPbNvXzAhUvQfX2PmFTpcceGg2",mainnet:"CRhtqXk98ATqo1R8gLg7qcpEMuvoPzqD5GNicPPqLMD"},t.HASHFLOW_FEE_COLLECTOR_ADDRESS={devnet:"5KWHDibWCaH9AEoGLUyYwuxCd5umT7miqXgpanSeAk44",mainnet:"DxnbcFdLBRKgsUXRDTg4Keb78NXVHFWjK7igJsGqKN7s"},t.WORMHOLE_PROGRAM_ADDRESS={localnet:"Bridge1p5gheXUvJ6jGWGeCsgPKgnE3YgdGKRVCMY9o",devnet:"3u8hJUVTA4jH1wYAyUur7FFZVQ8H635K3tSHHF4ssjQ5",mainnet:"worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth"}},47622:function(e,t,o){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,o,r){void 0===r&&(r=o);var n=Object.getOwnPropertyDescriptor(t,o);(!n||("get"in n?!t.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return t[o]}}),Object.defineProperty(e,r,n)}:function(e,t,o,r){void 0===r&&(r=o),e[r]=t[o]}),n=this&&this.__exportStar||function(e,t){for(var o in e)"default"===o||Object.prototype.hasOwnProperty.call(t,o)||r(t,e,o)},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.HashflowSolanaIDL=void 0;var a=o(10390);Object.defineProperty(t,"HashflowSolanaIDL",{enumerable:!0,get:function(){return s(a).default}}),n(o(50649),t),n(o(77080),t)},77080:function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0})},83742:function(e,t,o){"use strict";var r=o(48834).Buffer;/**
 * Support for translating between Buffer instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */class n{constructor(e,t){if(!Number.isInteger(e))throw TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}decode(e,t){throw Error("Layout is abstract")}encode(e,t,o){throw Error("Layout is abstract")}getSpan(e,t){if(0>this.span)throw RangeError("indeterminate span");return this.span}replicate(e){let t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function s(e,t){return t.property?e+"["+t.property+"]":e}t.Layout=n,t.nameWithProperty=s,t.bindConstructorLayout=function(e,t){if("function"!=typeof e)throw TypeError("Class must be constructor");if(e.hasOwnProperty("layout_"))throw Error("Class is already bound to a layout");if(!(t&&t instanceof n))throw TypeError("layout must be a Layout");if(t.hasOwnProperty("boundConstructor_"))throw Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value:function(e,o){return t.encode(this,e,o)},writable:!0}),Object.defineProperty(e,"decode",{value:function(e,o){return t.decode(e,o)},writable:!0})};class a extends n{isCount(){throw Error("ExternalLayout is abstract")}}class i extends a{constructor(e,t){if(void 0===e&&(e=1),!Number.isInteger(e)||0>=e)throw TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t){void 0===t&&(t=0);let o=e.length-t;return Math.floor(o/this.elementSpan)}encode(e,t,o){return 0}}class u extends a{constructor(e,t,o){if(!(e instanceof n))throw TypeError("layout must be a Layout");if(void 0===t)t=0;else if(!Number.isInteger(t))throw TypeError("offset must be integer or undefined");super(e.span,o||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof c||this.layout instanceof l}decode(e,t){return void 0===t&&(t=0),this.layout.decode(e,t+this.offset)}encode(e,t,o){return void 0===o&&(o=0),this.layout.encode(e,t,o+this.offset)}}class c extends n{constructor(e,t){if(super(e,t),6<this.span)throw RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readUIntLE(t,this.span)}encode(e,t,o){return void 0===o&&(o=0),t.writeUIntLE(e,o,this.span),this.span}}class l extends n{constructor(e,t){if(super(e,t),6<this.span)throw RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readUIntBE(t,this.span)}encode(e,t,o){return void 0===o&&(o=0),t.writeUIntBE(e,o,this.span),this.span}}class d extends n{constructor(e,t){if(super(e,t),6<this.span)throw RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readIntLE(t,this.span)}encode(e,t,o){return void 0===o&&(o=0),t.writeIntLE(e,o,this.span),this.span}}class m extends n{constructor(e,t){if(super(e,t),6<this.span)throw RangeError("span must not exceed 6 bytes")}decode(e,t){return void 0===t&&(t=0),e.readIntBE(t,this.span)}encode(e,t,o){return void 0===o&&(o=0),t.writeIntBE(e,o,this.span),this.span}}function h(e){let t=Math.floor(e/4294967296);return{hi32:t,lo32:e-4294967296*t}}function f(e,t){return 4294967296*e+t}class p extends n{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);let o=e.readUInt32LE(t),r=e.readUInt32LE(t+4);return f(r,o)}encode(e,t,o){void 0===o&&(o=0);let r=h(e);return t.writeUInt32LE(r.lo32,o),t.writeUInt32LE(r.hi32,o+4),8}}class g extends n{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);let o=e.readUInt32BE(t),r=e.readUInt32BE(t+4);return f(o,r)}encode(e,t,o){void 0===o&&(o=0);let r=h(e);return t.writeUInt32BE(r.hi32,o),t.writeUInt32BE(r.lo32,o+4),8}}class y extends n{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);let o=e.readUInt32LE(t),r=e.readInt32LE(t+4);return f(r,o)}encode(e,t,o){void 0===o&&(o=0);let r=h(e);return t.writeUInt32LE(r.lo32,o),t.writeInt32LE(r.hi32,o+4),8}}class w extends n{constructor(e){super(8,e)}decode(e,t){void 0===t&&(t=0);let o=e.readInt32BE(t),r=e.readUInt32BE(t+4);return f(o,r)}encode(e,t,o){void 0===o&&(o=0);let r=h(e);return t.writeInt32BE(r.hi32,o),t.writeUInt32BE(r.lo32,o+4),8}}class b extends n{constructor(e){super(4,e)}decode(e,t){return void 0===t&&(t=0),e.readFloatLE(t)}encode(e,t,o){return void 0===o&&(o=0),t.writeFloatLE(e,o),4}}class S extends n{constructor(e){super(4,e)}decode(e,t){return void 0===t&&(t=0),e.readFloatBE(t)}encode(e,t,o){return void 0===o&&(o=0),t.writeFloatBE(e,o),4}}class v extends n{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),e.readDoubleLE(t)}encode(e,t,o){return void 0===o&&(o=0),t.writeDoubleLE(e,o),8}}class M extends n{constructor(e){super(8,e)}decode(e,t){return void 0===t&&(t=0),e.readDoubleBE(t)}encode(e,t,o){return void 0===o&&(o=0),t.writeDoubleBE(e,o),8}}class k extends n{constructor(e,t,o){if(!(e instanceof n))throw TypeError("elementLayout must be a Layout");if(!(t instanceof a&&t.isCount()||Number.isInteger(t)&&0<=t))throw TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;t instanceof a||!(0<e.span)||(r=t*e.span),super(r,o),this.elementLayout=e,this.count=t}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let o=0,r=this.count;if(r instanceof a&&(r=r.decode(e,t)),0<this.elementLayout.span)o=r*this.elementLayout.span;else{let n=0;for(;n<r;)o+=this.elementLayout.getSpan(e,t+o),++n}return o}decode(e,t){void 0===t&&(t=0);let o=[],r=0,n=this.count;for(n instanceof a&&(n=n.decode(e,t));r<n;)o.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return o}encode(e,t,o){void 0===o&&(o=0);let r=this.elementLayout,n=e.reduce((e,n)=>e+r.encode(n,t,o+e),0);return this.count instanceof a&&this.count.encode(e.length,t,o),n}}class P extends n{constructor(e,t,o){if(!(Array.isArray(e)&&e.reduce((e,t)=>e&&t instanceof n,!0)))throw TypeError("fields must be array of Layout instances");for(let r of("boolean"==typeof t&&void 0===o&&(o=t,t=void 0),e))if(0>r.span&&void 0===r.property)throw Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce((e,t)=>e+t.getSpan(),0)}catch(e){}super(r,t),this.fields=e,this.decodePrefixes=!!o}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let o=0;try{o=this.fields.reduce((o,r)=>{let n=r.getSpan(e,t);return t+=n,o+n},0)}catch(e){throw RangeError("indeterminate span")}return o}decode(e,t){void 0===t&&(t=0);let o=this.makeDestinationObject();for(let r of this.fields)if(void 0!==r.property&&(o[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return o}encode(e,t,o){void 0===o&&(o=0);let r=o,n=0,s=0;for(let r of this.fields){let a=r.span;if(s=0<a?a:0,void 0!==r.property){let n=e[r.property];void 0!==n&&(s=r.encode(n,t,o),0>a&&(a=r.getSpan(t,o)))}n=o,o+=a}return n+s-r}fromArray(e){let t=this.makeDestinationObject();for(let o of this.fields)void 0!==o.property&&0<e.length&&(t[o.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw TypeError("property must be string");let t=0;for(let o of this.fields){if(o.property===e)return t;0>o.span?t=-1:0<=t&&(t+=o.span)}}}class A{constructor(e){this.property=e}decode(){throw Error("UnionDiscriminator is abstract")}encode(){throw Error("UnionDiscriminator is abstract")}}class T extends A{constructor(e,t){if(!(e instanceof a&&e.isCount()))throw TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,o){return this.layout.encode(e,t,o)}}class E extends n{constructor(e,t,o){let r=e instanceof c||e instanceof l;if(r)e=new T(new u(e));else if(e instanceof a&&e.isCount())e=new T(e);else if(!(e instanceof A))throw TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(void 0===t&&(t=null),!(null===t||t instanceof n))throw TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let s=-1;t&&0<=(s=t.span)&&r&&(s+=e.layout.span),super(s,o),this.discriminator=e,this.usesPrefixDiscriminator=r,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return i(e)},this.configGetSourceVariant=function(e){i=e.bind(this)}}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let o=this.getVariant(e,t);if(!o)throw Error("unable to determine span for unrecognized variant");return o.getSpan(e,t)}defaultGetSourceVariant(e){if(e.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&e.hasOwnProperty(this.defaultLayout.property))return;let t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||e.hasOwnProperty(t.property)))return t}else for(let t in this.registry){let o=this.registry[t];if(e.hasOwnProperty(o.property))return o}throw Error("unable to infer src variant")}decode(e,t){let o;void 0===t&&(t=0);let r=this.discriminator,n=r.decode(e,t),s=this.registry[n];if(void 0===s){let a=0;s=this.defaultLayout,this.usesPrefixDiscriminator&&(a=r.layout.span),(o=this.makeDestinationObject())[r.property]=n,o[s.property]=this.defaultLayout.decode(e,t+a)}else o=s.decode(e,t);return o}encode(e,t,o){void 0===o&&(o=0);let r=this.getSourceVariant(e);if(void 0===r){let r=this.discriminator,n=this.defaultLayout,s=0;return this.usesPrefixDiscriminator&&(s=r.layout.span),r.encode(e[r.property],t,o),s+n.encode(e[n.property],t,o+s)}return r.encode(e,t,o)}addVariant(e,t,o){let r=new C(this,e,t,o);return this.registry[e]=r,r}getVariant(e,t){let o=e;return r.isBuffer(e)&&(void 0===t&&(t=0),o=this.discriminator.decode(e,t)),this.registry[o]}}class C extends n{constructor(e,t,o,r){if(!(e instanceof E))throw TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw TypeError("variant must be a (non-negative) integer");if("string"==typeof o&&void 0===r&&(r=o,o=null),o){if(!(o instanceof n))throw TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=o.span&&o.span>e.defaultLayout.span)throw Error("variant span exceeds span of containing union");if("string"!=typeof r)throw TypeError("variant must have a String property")}let s=e.span;0>e.span&&0<=(s=o?o.span:0)&&e.usesPrefixDiscriminator&&(s+=e.discriminator.layout.span),super(s,r),this.union=e,this.variant=t,this.layout=o||null}getSpan(e,t){if(0<=this.span)return this.span;void 0===t&&(t=0);let o=0;return this.union.usesPrefixDiscriminator&&(o=this.union.discriminator.layout.span),o+this.layout.getSpan(e,t+o)}decode(e,t){let o=this.makeDestinationObject();if(void 0===t&&(t=0),this!==this.union.getVariant(e,t))throw Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?o[this.property]=this.layout.decode(e,t+r):this.property?o[this.property]=!0:this.union.usesPrefixDiscriminator&&(o[this.union.discriminator.property]=this.variant),o}encode(e,t,o){void 0===o&&(o=0);let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!e.hasOwnProperty(this.property))throw TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,o);let n=r;if(this.layout&&(this.layout.encode(e[this.property],t,o+r),n+=this.layout.getSpan(t,o+r),0<=this.union.span&&n>this.union.span))throw Error("encoded variant overruns containing union");return n}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function I(e){return 0>e&&(e+=4294967296),e}class x extends n{constructor(e,t,o){if(!(e instanceof c||e instanceof l))throw TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===o&&(o=t,t=void 0),4<e.span)throw RangeError("word cannot exceed 32 bits");super(e.span,o),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(e){return r=I(e),this},this._packedGetValue=function(){return r}}decode(e,t){let o=this.makeDestinationObject();void 0===t&&(t=0);let r=this.word.decode(e,t);for(let e of(this._packedSetValue(r),this.fields))void 0!==e.property&&(o[e.property]=e.decode(r));return o}encode(e,t,o){void 0===o&&(o=0);let r=this.word.decode(t,o);for(let t of(this._packedSetValue(r),this.fields))if(void 0!==t.property){let o=e[t.property];void 0!==o&&t.encode(o)}return this.word.encode(this._packedGetValue(),t,o)}addField(e,t){let o=new F(this,e,t);return this.fields.push(o),o}addBoolean(e){let t=new L(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw TypeError("property must be string");for(let t of this.fields)if(t.property===e)return t}}class F{constructor(e,t,o){if(!(e instanceof x))throw TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw TypeError("bits must be positive integer");let r=8*e.span,n=e.fields.reduce((e,t)=>e+t.bits,0);if(t+n>r)throw Error("bits too long for span remainder ("+(r-n)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=n,this.container.msb&&(this.start=r-n-t),this.wordMask=I(this.valueMask<<this.start),this.property=o}decode(){let e=this.container._packedGetValue(),t=I(e&this.wordMask),o=t>>>this.start;return o}encode(e){if(!Number.isInteger(e)||e!==I(e&this.valueMask))throw TypeError(s("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);let t=this.container._packedGetValue(),o=I(e<<this.start);this.container._packedSetValue(I(t&~this.wordMask)|o)}}class L extends F{constructor(e,t){super(e,1,t)}decode(e,t){return!!F.prototype.decode.call(this,e,t)}encode(e){return"boolean"==typeof e&&(e=+e),F.prototype.encode.call(this,e)}}class D extends n{constructor(e,t){if(!(e instanceof a&&e.isCount()||Number.isInteger(e)&&0<=e))throw TypeError("length must be positive integer or an unsigned integer ExternalLayout");let o=-1;e instanceof a||(o=e),super(o,t),this.length=e}getSpan(e,t){let o=this.span;return 0>o&&(o=this.length.decode(e,t)),o}decode(e,t){void 0===t&&(t=0);let o=this.span;return 0>o&&(o=this.length.decode(e,t)),e.slice(t,t+o)}encode(e,t,o){let n=this.length;if(this.length instanceof a&&(n=e.length),!(r.isBuffer(e)&&n===e.length))throw TypeError(s("Blob.encode",this)+" requires (length "+n+") Buffer as src");if(o+n>t.length)throw RangeError("encoding overruns Buffer");return t.write(e.toString("hex"),o,n,"hex"),this.length instanceof a&&this.length.encode(n,t,o),n}}class W extends n{constructor(e){super(-1,e)}getSpan(e,t){if(!r.isBuffer(e))throw TypeError("b must be a Buffer");void 0===t&&(t=0);let o=t;for(;o<e.length&&0!==e[o];)o+=1;return 1+o-t}decode(e,t,o){void 0===t&&(t=0);let r=this.getSpan(e,t);return e.slice(t,t+r-1).toString("utf-8")}encode(e,t,o){void 0===o&&(o=0),"string"!=typeof e&&(e=e.toString());let n=new r(e,"utf8"),s=n.length;if(o+s>t.length)throw RangeError("encoding overruns Buffer");return n.copy(t,o),t[o+s]=0,s+1}}class _ extends n{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t){if(!r.isBuffer(e))throw TypeError("b must be a Buffer");return void 0===t&&(t=0),e.length-t}decode(e,t,o){void 0===t&&(t=0);let r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw RangeError("text length exceeds maxSpan");return e.slice(t,t+r).toString("utf-8")}encode(e,t,o){void 0===o&&(o=0),"string"!=typeof e&&(e=e.toString());let n=new r(e,"utf8"),s=n.length;if(0<=this.maxSpan&&this.maxSpan<s)throw RangeError("text length exceeds maxSpan");if(o+s>t.length)throw RangeError("encoding overruns Buffer");return n.copy(t,o),s}}class R extends n{constructor(e,t){super(0,t),this.value=e}decode(e,t,o){return this.value}encode(e,t,o){return 0}}t.ExternalLayout=a,t.GreedyCount=i,t.OffsetLayout=u,t.UInt=c,t.UIntBE=l,t.Int=d,t.IntBE=m,t.Float=b,t.FloatBE=S,t.Double=v,t.DoubleBE=M,t.Sequence=k,t.Structure=P,t.UnionDiscriminator=A,t.UnionLayoutDiscriminator=T,t.Union=E,t.VariantLayout=C,t.BitStructure=x,t.BitField=F,t.Boolean=L,t.Blob=D,t.CString=W,t.UTF8=_,t.Constant=R,t.greedy=(e,t)=>new i(e,t),t.offset=(e,t,o)=>new u(e,t,o),t.u8=e=>new c(1,e),t.u16=e=>new c(2,e),t.u24=e=>new c(3,e),t.u32=e=>new c(4,e),t.u40=e=>new c(5,e),t.u48=e=>new c(6,e),t.nu64=e=>new p(e),t.u16be=e=>new l(2,e),t.u24be=e=>new l(3,e),t.u32be=e=>new l(4,e),t.u40be=e=>new l(5,e),t.u48be=e=>new l(6,e),t.nu64be=e=>new g(e),t.s8=e=>new d(1,e),t.s16=e=>new d(2,e),t.s24=e=>new d(3,e),t.s32=e=>new d(4,e),t.s40=e=>new d(5,e),t.s48=e=>new d(6,e),t.ns64=e=>new y(e),t.s16be=e=>new m(2,e),t.s24be=e=>new m(3,e),t.s32be=e=>new m(4,e),t.s40be=e=>new m(5,e),t.s48be=e=>new m(6,e),t.ns64be=e=>new w(e),t.f32=e=>new b(e),t.f32be=e=>new S(e),t.f64=e=>new v(e),t.f64be=e=>new M(e),t.struct=(e,t,o)=>new P(e,t,o),t.bits=(e,t,o)=>new x(e,t,o),t.seq=(e,t,o)=>new k(e,t,o),t.union=(e,t,o)=>new E(e,t,o),t.unionLayoutDiscriminator=(e,t)=>new T(e,t),t.blob=(e,t)=>new D(e,t),t.cstr=e=>new W(e),t.utf8=(e,t)=>new _(e,t),t.const=(e,t)=>new R(e,t)},78783:function(e){"use strict";let t=/[\p{Lu}]/u,o=/[\p{Ll}]/u,r=/^[\p{Lu}](?![\p{Lu}])/gu,n=/([\p{Alpha}\p{N}_]|$)/u,s=/[_.\- ]+/,a=RegExp("^"+s.source),i=RegExp(s.source+n.source,"gu"),u=RegExp("\\d+"+n.source,"gu"),c=(e,r,n)=>{let s=!1,a=!1,i=!1;for(let u=0;u<e.length;u++){let c=e[u];s&&t.test(c)?(e=e.slice(0,u)+"-"+e.slice(u),s=!1,i=a,a=!0,u++):a&&i&&o.test(c)?(e=e.slice(0,u-1)+"-"+e.slice(u-1),i=a,a=!1,s=!0):(s=r(c)===c&&n(c)!==c,i=a,a=n(c)===c&&r(c)!==c)}return e},l=(e,t)=>(r.lastIndex=0,e.replace(r,e=>t(e))),d=(e,t)=>(i.lastIndex=0,u.lastIndex=0,e.replace(i,(e,o)=>t(o)).replace(u,e=>t(e))),m=(e,t)=>{if(!("string"==typeof e||Array.isArray(e)))throw TypeError("Expected the input to be `string | string[]`");if(t={pascalCase:!1,preserveConsecutiveUppercase:!1,...t},0===(e=Array.isArray(e)?e.map(e=>e.trim()).filter(e=>e.length).join("-"):e.trim()).length)return"";let o=!1===t.locale?e=>e.toLowerCase():e=>e.toLocaleLowerCase(t.locale),r=!1===t.locale?e=>e.toUpperCase():e=>e.toLocaleUpperCase(t.locale);if(1===e.length)return t.pascalCase?r(e):o(e);let n=e!==o(e);return n&&(e=c(e,o,r)),e=e.replace(a,""),e=t.preserveConsecutiveUppercase?l(e,o):o(e),t.pascalCase&&(e=r(e.charAt(0))+e.slice(1)),d(e,r)};e.exports=m,e.exports.default=m},88855:function(e,t,o){"use strict";o.d(t,{AG:function(){return w},G0:function(){return A},IM:function(){return v},IX:function(){return f},O7:function(){return p},Rx:function(){return b},Ue:function(){return c},Yj:function(){return h},Z_:function(){return M},_4:function(){return T},bc:function(){return k},dt:function(){return P},eE:function(){return g},i0:function(){return y},jt:function(){return S},oQ:function(){return E}}),o(23716);class r extends TypeError{constructor(e,t){let o;let{message:r,...n}=e,{path:s}=e,a=0===s.length?r:"At path: "+s.join(".")+" -- "+r;super(a),Object.assign(this,n),this.name=this.constructor.name,this.failures=()=>{var r;return null!=(r=o)?r:o=[e,...t()]}}}function n(e){return"object"==typeof e&&null!=e}function s(e){return"string"==typeof e?JSON.stringify(e):""+e}function*a(e,t,o,r){var a;for(let i of(n(a=e)&&"function"==typeof a[Symbol.iterator]||(e=[e]),e)){let e=function(e,t,o,r){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});let{path:n,branch:a}=t,{type:i}=o,{refinement:u,message:c="Expected a value of type `"+i+"`"+(u?" with refinement `"+u+"`":"")+", but received: `"+s(r)+"`"}=e;return{value:r,type:i,refinement:u,key:n[n.length-1],path:n,branch:a,...e,message:c}}(i,t,o,r);e&&(yield e)}}function*i(e,t,o={}){let{path:r=[],branch:s=[e],coerce:a=!1,mask:u=!1}=o,c={path:r,branch:s};if(a&&(e=t.coercer(e,c),u&&"type"!==t.type&&n(t.schema)&&n(e)&&!Array.isArray(e)))for(let o in e)void 0===t.schema[o]&&delete e[o];let l=!0;for(let o of t.validator(e,c))l=!1,yield[o,void 0];for(let[o,d,m]of t.entries(e,c)){let t=i(d,m,{path:void 0===o?r:[...r,o],branch:void 0===o?s:[...s,d],coerce:a,mask:u});for(let r of t)r[0]?(l=!1,yield[r[0],void 0]):a&&(d=r[1],void 0===o?e=d:e instanceof Map?e.set(o,d):e instanceof Set?e.add(d):n(e)&&(e[o]=d))}if(l)for(let o of t.refiner(e,c))l=!1,yield[o,void 0];l&&(yield[void 0,e])}class u{constructor(e){let{type:t,schema:o,validator:r,refiner:n,coercer:s=e=>e,entries:i=function*(){}}=e;this.type=t,this.schema=o,this.entries=i,this.coercer=s,r?this.validator=(e,t)=>{let o=r(e,t);return a(o,t,this,e)}:this.validator=()=>[],n?this.refiner=(e,t)=>{let o=n(e,t);return a(o,t,this,e)}:this.refiner=()=>[]}assert(e){return function(e,t){let o=d(e,t);if(o[0])throw o[0]}(e,this)}create(e){return c(e,this)}is(e){return l(e,this)}mask(e){return function(e,t){let o=d(e,t,{coerce:!0,mask:!0});if(!o[0])return o[1];throw o[0]}(e,this)}validate(e,t={}){return d(e,this,t)}}function c(e,t){let o=d(e,t,{coerce:!0});if(!o[0])return o[1];throw o[0]}function l(e,t){let o=d(e,t);return!o[0]}function d(e,t,o={}){let n=i(e,t,o),s=function(e){let{done:t,value:o}=e.next();return t?void 0:o}(n);if(s[0]){let e=new r(s[0],function*(){for(let e of n)e[0]&&(yield e[0])});return[e,void 0]}{let e=s[1];return[void 0,e]}}function m(e,t){return new u({type:e,schema:null,validator:t})}function h(){return m("any",()=>!0)}function f(e){return new u({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(let[o,r]of t.entries())yield[o,r,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+s(e)})}function p(){return m("boolean",e=>"boolean"==typeof e)}function g(e){return m("instance",t=>t instanceof e||"Expected a `"+e.name+"` instance, but received: "+s(t))}function y(e){let t=s(e),o=typeof e;return new u({type:"literal",schema:"string"===o||"number"===o||"boolean"===o?e:null,validator:o=>o===e||"Expected the literal `"+t+"`, but received: "+s(o)})}function w(e){return new u({...e,validator:(t,o)=>null===t||e.validator(t,o),refiner:(t,o)=>null===t||e.refiner(t,o)})}function b(){return m("number",e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+s(e))}function S(e){return new u({...e,validator:(t,o)=>void 0===t||e.validator(t,o),refiner:(t,o)=>void 0===t||e.refiner(t,o)})}function v(e,t){return new u({type:"record",schema:null,*entries(o){if(n(o))for(let r in o){let n=o[r];yield[r,r,e],yield[r,n,t]}},validator:e=>n(e)||"Expected an object, but received: "+s(e)})}function M(){return m("string",e=>"string"==typeof e||"Expected a string, but received: "+s(e))}function k(e){let t=m("never",()=>!1);return new u({type:"tuple",schema:null,*entries(o){if(Array.isArray(o)){let r=Math.max(e.length,o.length);for(let n=0;n<r;n++)yield[n,o[n],e[n]||t]}},validator:e=>Array.isArray(e)||"Expected an array, but received: "+s(e)})}function P(e){let t=Object.keys(e);return new u({type:"type",schema:e,*entries(o){if(n(o))for(let r of t)yield[r,o[r],e[r]]},validator:e=>n(e)||"Expected an object, but received: "+s(e)})}function A(e){let t=e.map(e=>e.type).join(" | ");return new u({type:"union",schema:null,validator(o,r){let n=[];for(let t of e){let[...e]=i(o,t,r),[s]=e;if(!s[0])return[];for(let[t]of e)t&&n.push(t)}return["Expected the value to satisfy a union of `"+t+"`, but received: "+s(o),...n]}})}function T(){return m("unknown",()=>!0)}function E(e,t,o){return new u({...e,coercer:(r,n)=>l(r,t)?e.coercer(o(r,n),n):e.coercer(r,n)})}},10390:function(e){"use strict";e.exports=JSON.parse('{"version":"0.1.0","name":"protocol_solana","instructions":[{"name":"initialize","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Program owner."]},{"name":"config","isMut":true,"isSigner":false,"docs":["Program config."]},{"name":"hashflowFeeCollector","isMut":false,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"hashflowChainId","type":"u16"}]},{"name":"initializeWormhole","accounts":[{"name":"owner","isMut":true,"isSigner":true},{"name":"config","isMut":false,"isSigner":false,"docs":["Used to check the current Hashflow Chain ID."]},{"name":"wormholeConfig","isMut":true,"isSigner":false,"docs":["Wormhole configuration account."]},{"name":"wormholeBridge","isMut":true,"isSigner":false,"docs":["Wormhole bridge data account (a.k.a. its config).","[`wormhole::post_message`] requires this account be mutable."]},{"name":"wormholeFeeCollector","isMut":true,"isSigner":false,"docs":["Wormhole fee collector account, which requires lamports before the","program can post a message (if there is a fee).","[`wormhole::post_message`] requires this account be mutable."]},{"name":"wormholeEmitter","isMut":true,"isSigner":false,"docs":["This program\'s emitter account. We create this account in the","[`initialize`](crate::initialize) instruction, but","[`wormhole::post_message`] only needs it to be read-only."]},{"name":"wormholeSequence","isMut":true,"isSigner":false,"docs":["message is posted, so it needs to be an [UncheckedAccount] for the","[`initialize`](crate::initialize) instruction.","[`wormhole::post_message`] requires this account be mutable."]},{"name":"wormholeMessage","isMut":true,"isSigner":false,"docs":["account, which requires this program\'s signature.","[`wormhole::post_message`] requires this account be mutable."]},{"name":"clock","isMut":false,"isSigner":false,"docs":["Clock sysvar."]},{"name":"rent","isMut":false,"isSigner":false,"docs":["Rent sysvar."]},{"name":"wormholeProgram","isMut":false,"isSigner":false,"docs":["Wormhole program."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[]},{"name":"updateHashflowFeeCollector","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Program owner."]},{"name":"config","isMut":true,"isSigner":false,"docs":["Program config."]},{"name":"hashflowFeeCollector","isMut":false,"isSigner":false,"docs":["In this instruction, we update this account."]}],"args":[]},{"name":"registerForeignHashflowChain","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Program owner."]},{"name":"config","isMut":false,"isSigner":false,"docs":["Used to check the current Hashflow Chain ID."]},{"name":"wormholeConfig","isMut":false,"isSigner":false,"docs":["Used to check the current Wormhole Chain ID."]},{"name":"hashflowChainMetadata","isMut":true,"isSigner":false,"docs":["Hashflow Chain Metadata for the new chain."]},{"name":"wormholeChainMetadata","isMut":true,"isSigner":false,"docs":["Wormhole Chain Metadata for the new chain."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"hashflowChainId","type":"u16"},{"name":"wormholeChainId","type":"u16"}]},{"name":"unregisterForeignHashflowChain","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Program owner."]},{"name":"config","isMut":false,"isSigner":false,"docs":["Used to check the current Hashflow Chain ID."]},{"name":"hashflowChainMetadata","isMut":true,"isSigner":false,"docs":["Hashflow Chain Metadata for the chain."]},{"name":"wormholeChainMetadata","isMut":true,"isSigner":false,"docs":["Wormhole Chain Metadata for the chain."]}],"args":[{"name":"hashflowChainId","type":"u16"},{"name":"wormholeChainId","type":"u16"}]},{"name":"registerWormholeForeignEmitter","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Program owner."]},{"name":"config","isMut":false,"isSigner":false,"docs":["Program config."]},{"name":"wormholeConfig","isMut":false,"isSigner":false,"docs":["Wormhole config."]},{"name":"emitter","isMut":true,"isSigner":false,"docs":["Foreign Wormhole emitter account."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"wormholeChainId","type":"u16"},{"name":"emitterAddress","type":{"array":["u8",32]}}]},{"name":"createPool","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Market Maker."]},{"name":"pool","isMut":true,"isSigner":false,"docs":["Pool account."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"poolId","type":"u64"},{"name":"quoteSignerPubKey","type":{"array":["u8",64]}}]},{"name":"updateQuoteSigner","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Market Maker."]},{"name":"pool","isMut":true,"isSigner":false,"docs":["Pool account."]}],"args":[{"name":"newQuoteSignerPubKey","type":{"array":["u8",64]}}]},{"name":"updateXChainPoolAuthorization","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Market Maker."]},{"name":"config","isMut":false,"isSigner":false,"docs":["Program config."]},{"name":"pool","isMut":true,"isSigner":false,"docs":["Pool PDA."]},{"name":"xChainPoolAuthorization","isMut":true,"isSigner":false,"docs":["X-Chain Pool authorization account."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"srcHashflowChainId","type":"u16"},{"name":"srcPool","type":{"array":["u8",32]}},{"name":"status","type":"bool"}]},{"name":"deposit","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Market Maker."]},{"name":"tokenMint","isMut":false,"isSigner":false,"docs":["Mint of the token to deposit."]},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool account."]},{"name":"ownerTokenAccount","isMut":true,"isSigner":false,"docs":["Token account of the owner."]},{"name":"poolTokenAccount","isMut":true,"isSigner":false,"docs":["Associated token account of the pool PDA."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token program."]},{"name":"associatedTokenProgram","isMut":false,"isSigner":false,"docs":["Associated Token program."]}],"args":[{"name":"amount","type":"u64"}]},{"name":"withdraw","accounts":[{"name":"owner","isMut":true,"isSigner":true,"docs":["Market Maker."]},{"name":"tokenMint","isMut":false,"isSigner":false,"docs":["Mint of the token being withdrawn."]},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool account."]},{"name":"ownerTokenAccount","isMut":true,"isSigner":false,"docs":["Market Maker account to withdraw to."]},{"name":"poolTokenAccount","isMut":true,"isSigner":false,"docs":["Token account of the Pool."]},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token program."]}],"args":[{"name":"amount","type":"u64"}]},{"name":"trade","accounts":[{"name":"payer","isMut":true,"isSigner":true,"docs":["Account paying for the transaction."]},{"name":"trader","isMut":false,"isSigner":true,"docs":["Account to be debited \\"From\\" token."]},{"name":"tokenFromMint","isMut":false,"isSigner":false,"docs":["Mint of the \\"From\\" token."]},{"name":"tokenToMint","isMut":false,"isSigner":false,"docs":["Mint of the \\"To\\" token."]},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool account."]},{"name":"tradeReceipt","isMut":true,"isSigner":false,"docs":["Trade receipt account, used for off-chain indexing."]},{"name":"tokenFromTraderAccount","isMut":true,"isSigner":false,"docs":["Trader\'s Token Account for the \\"From\\" token."]},{"name":"tokenFromPoolAccount","isMut":true,"isSigner":false,"docs":["Pool\'s Token Account for the \\"From\\" token.","Using associated token accounts."]},{"name":"tokenToTraderAccount","isMut":true,"isSigner":false,"docs":["Trader\'s Token Account for the \\"To\\" token.","Authority not checked, but enforced as part of the quote signature."]},{"name":"tokenToPoolAccount","isMut":true,"isSigner":false,"docs":["Pool\'s Token Account for the \\"To\\" token.","Using associated token accounts. Does not require init, since","we have to transfer balance out of this account."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token program."]},{"name":"associatedTokenProgram","isMut":false,"isSigner":false,"docs":["Associated Token program."]}],"args":[{"name":"txid","type":{"array":["u8",32]}},{"name":"tokenFromAmount","type":"u64"},{"name":"tokenToAmount","type":"u64"},{"name":"quoteExpiry","type":"u64"},{"name":"signature","type":{"array":["u8",64]}},{"name":"recoveryId","type":"u8"},{"name":"minTokenFromAmount","type":"u64"},{"name":"effectiveTokenFromAmount","type":"u64"}]},{"name":"tradeXChain","accounts":[{"name":"payer","isMut":true,"isSigner":true,"docs":["Payer."]},{"name":"trader","isMut":true,"isSigner":true,"docs":["Account to be debited \\"From\\" token."]},{"name":"config","isMut":false,"isSigner":false,"docs":["Config account. Wormhole PDAs specified in the config are checked","against the Wormhole accounts in this context. Read-only."]},{"name":"outboundXChainTradeReceipt","isMut":true,"isSigner":false,"docs":["Receipt account."]},{"name":"tokenFromMint","isMut":false,"isSigner":false},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool PDA."]},{"name":"tokenFromTraderAccount","isMut":true,"isSigner":false,"docs":["Trader\'s Token Account for the \\"From\\" token."]},{"name":"tokenFromPoolAccount","isMut":true,"isSigner":false,"docs":["Pool\'s Token Account for the \\"From\\" token."]},{"name":"poolAuthorization","isMut":false,"isSigner":false,"docs":["Account checking x-chain pool authorization."]},{"name":"hashflowFeeCollector","isMut":true,"isSigner":false},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token program."]},{"name":"associatedTokenProgram","isMut":false,"isSigner":false,"docs":["Associated Token program."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]},{"name":"clock","isMut":false,"isSigner":false,"docs":["Clock sysvar."]}],"args":[{"name":"txid","type":{"array":["u8",32]}},{"name":"dstHashflowChainId","type":"u16"},{"name":"dstPool","type":{"array":["u8",32]}},{"name":"dstExternalAccount","type":{"array":["u8",32]}},{"name":"tokenToAddress","type":{"array":["u8",32]}},{"name":"traderTo","type":{"array":["u8",32]}},{"name":"tokenFromAmount","type":"u64"},{"name":"tokenToAmount","type":{"array":["u8",32]}},{"name":"quoteExpiry","type":"u64"},{"name":"signature","type":{"array":["u8",64]}},{"name":"recoveryId","type":"u8"},{"name":"minTokenFromAmount","type":"u64"},{"name":"effectiveTokenFromAmount","type":"u64"},{"name":"relayerFee","type":"u64"}]},{"name":"tradeXChainAndSend","accounts":[{"name":"payer","isMut":true,"isSigner":true,"docs":["Payer."]},{"name":"trader","isMut":true,"isSigner":true,"docs":["Account to be debited \\"From\\" token."]},{"name":"config","isMut":false,"isSigner":false,"docs":["Config account. Wormhole PDAs specified in the config are checked","against the Wormhole accounts in this context. Read-only."]},{"name":"wormholeConfig","isMut":false,"isSigner":false,"docs":["Config account. Wormhole PDAs specified in the config are checked","against the Wormhole accounts in this context. Read-only."]},{"name":"wormholeBridge","isMut":true,"isSigner":false,"docs":["Wormhole bridge data. [`wormhole::post_message`] requires this account","be mutable."]},{"name":"wormholeFeeCollector","isMut":true,"isSigner":false,"docs":["Wormhole fee collector. [`wormhole::post_message`] requires this","account be mutable."]},{"name":"wormholeEmitter","isMut":false,"isSigner":false,"docs":["Program\'s emitter account. Read-only."]},{"name":"wormholeSequence","isMut":true,"isSigner":false,"docs":["Emitter\'s sequence account. [`wormhole::post_message`] requires this","account be mutable."]},{"name":"wormholeMessage","isMut":true,"isSigner":false,"docs":["account be mutable."]},{"name":"outboundXChainTradeReceipt","isMut":true,"isSigner":false},{"name":"tokenFromMint","isMut":false,"isSigner":false,"docs":["Mint of the \\"From\\" token."]},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool PDA."]},{"name":"tokenFromTraderAccount","isMut":true,"isSigner":false,"docs":["Trader\'s Token Account for the \\"From\\" token."]},{"name":"tokenFromPoolAccount","isMut":true,"isSigner":false,"docs":["Pool\'s Token Account for the \\"From\\" token."]},{"name":"poolAuthorization","isMut":false,"isSigner":false,"docs":["Checks that the destination pool is an authorized peer pool."]},{"name":"hashflowFeeCollector","isMut":true,"isSigner":false},{"name":"rent","isMut":false,"isSigner":false,"docs":["Rent sysvar."]},{"name":"clock","isMut":false,"isSigner":false,"docs":["Clock sysvar."]},{"name":"wormholeProgram","isMut":false,"isSigner":false,"docs":["Wormhole program."]},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token program."]},{"name":"associatedTokenProgram","isMut":false,"isSigner":false,"docs":["Associated Token program."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"txid","type":{"array":["u8",32]}},{"name":"dstHashflowChainId","type":"u16"},{"name":"dstPool","type":{"array":["u8",32]}},{"name":"dstExternalAccount","type":{"array":["u8",32]}},{"name":"tokenToAddress","type":{"array":["u8",32]}},{"name":"traderTo","type":{"array":["u8",32]}},{"name":"tokenFromAmount","type":"u64"},{"name":"tokenToAmount","type":{"array":["u8",32]}},{"name":"quoteExpiry","type":"u64"},{"name":"minTokenFromAmount","type":"u64"},{"name":"signature","type":{"array":["u8",64]}},{"name":"recoveryId","type":"u8"},{"name":"effectiveTokenFromAmount","type":"u64"},{"name":"relayerFee","type":"u64"}]},{"name":"wormholeSendXChainTrade","accounts":[{"name":"payer","isMut":true,"isSigner":true,"docs":["Payer."]},{"name":"outboundXChainTradeReceipt","isMut":true,"isSigner":false,"docs":["Outbound receipt account."]},{"name":"wormholeConfig","isMut":false,"isSigner":false,"docs":["Config account. Wormhole PDAs specified in the config are checked","against the Wormhole accounts in this context. Read-only."]},{"name":"wormholeProgram","isMut":false,"isSigner":false,"docs":["Wormhole program."]},{"name":"wormholeBridge","isMut":true,"isSigner":false,"docs":["Wormhole bridge data. [`wormhole::post_message`] requires this account","be mutable."]},{"name":"wormholeFeeCollector","isMut":true,"isSigner":false,"docs":["Wormhole fee collector. [`wormhole::post_message`] requires this","account be mutable."]},{"name":"wormholeEmitter","isMut":false,"isSigner":false,"docs":["Program\'s emitter account. Read-only."]},{"name":"wormholeSequence","isMut":true,"isSigner":false,"docs":["Emitter\'s sequence account. [`wormhole::post_message`] requires this","account be mutable."]},{"name":"wormholeMessage","isMut":true,"isSigner":false,"docs":["account be mutable."]},{"name":"clock","isMut":false,"isSigner":false,"docs":["Clock sysvar."]},{"name":"rent","isMut":false,"isSigner":false,"docs":["Rent sysvar."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]}],"args":[{"name":"txid","type":{"array":["u8",32]}}]},{"name":"wormholeReceiveXChainTrade","accounts":[{"name":"payer","isMut":true,"isSigner":true},{"name":"config","isMut":false,"isSigner":false},{"name":"posted","isMut":false,"isSigner":false,"docs":["Verified Wormhole message account. The Wormhole program verified","signatures and posted the account data here. Read-only."]},{"name":"wormholeForeignEmitter","isMut":false,"isSigner":false,"docs":["Wormhole Foreign emitter account. The posted message\'s `emitter_address` must","agree with the one we have registered for this message\'s `emitter_chain` (chain ID).","Read-only."]},{"name":"inboundXChainTradeReceipt","isMut":true,"isSigner":false,"docs":["Receipt account. Protects against replay."]},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool PDA."]},{"name":"hashflowChainMetadata","isMut":false,"isSigner":false,"docs":["Hashflow Chain Metadata."]},{"name":"wormholeChainMetadata","isMut":false,"isSigner":false,"docs":["Wormhole Chain Metadata."]},{"name":"poolAuthorization","isMut":false,"isSigner":false,"docs":["Account holding X-Chain pool authorization."]},{"name":"tokenToMint","isMut":false,"isSigner":false,"docs":["Mint of the \\"To\\" token."]},{"name":"tokenToTraderAccount","isMut":true,"isSigner":false,"docs":["Trader\'s Token Account for the \\"To\\" token."]},{"name":"tokenToPoolAccount","isMut":true,"isSigner":false,"docs":["Pool\'s Token Account for the \\"To\\" token."]},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token Program."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]},{"name":"wormholeProgram","isMut":false,"isSigner":false,"docs":["Wormhole program."]}],"args":[{"name":"vaaHash","type":{"array":["u8",32]}}]},{"name":"wormholeReceiveXChainNative","accounts":[{"name":"payer","isMut":true,"isSigner":true},{"name":"config","isMut":false,"isSigner":false},{"name":"posted","isMut":false,"isSigner":false,"docs":["Verified Wormhole message account. The Wormhole program verified","signatures and posted the account data here. Read-only."]},{"name":"wormholeForeignEmitter","isMut":false,"isSigner":false,"docs":["Wormhole Foreign emitter account. The posted message\'s `emitter_address` must","agree with the one we have registered for this message\'s `emitter_chain` (chain ID).","Read-only."]},{"name":"inboundXChainTradeReceipt","isMut":true,"isSigner":false,"docs":["Receipt account. Protects against replay."]},{"name":"pool","isMut":false,"isSigner":false,"docs":["Pool PDA."]},{"name":"hashflowChainMetadata","isMut":false,"isSigner":false,"docs":["Hashflow Chain Metadata."]},{"name":"wormholeChainMetadata","isMut":false,"isSigner":false,"docs":["Wormhole Chain Metadata."]},{"name":"poolAuthorization","isMut":false,"isSigner":false,"docs":["Account holding X-Chain pool authorization."]},{"name":"wsolMint","isMut":false,"isSigner":false,"docs":["Mint of the \\"To\\" token. This has to be WSOL, or closing the aux account will fail."]},{"name":"trader","isMut":true,"isSigner":false},{"name":"wsolPoolAccount","isMut":true,"isSigner":false,"docs":["Pool\'s Token Account for the \\"To\\" token."]},{"name":"wsolPoolAuxAccount","isMut":true,"isSigner":false},{"name":"associatedTokenProgram","isMut":false,"isSigner":false},{"name":"tokenProgram","isMut":false,"isSigner":false,"docs":["Token Program."]},{"name":"systemProgram","isMut":false,"isSigner":false,"docs":["System program."]},{"name":"wormholeProgram","isMut":false,"isSigner":false,"docs":["Wormhole program."]}],"args":[{"name":"vaaHash","type":{"array":["u8",32]}}]}],"accounts":[{"name":"Config","docs":["Main program configuration."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"owner","docs":["Program\'s owner."],"type":"publicKey"},{"name":"hashflowChainId","docs":["The Hashflow Chain ID."],"type":"u16"},{"name":"hashflowFeeCollector","docs":["Account collecting lamports for X-Chain relays."],"type":"publicKey"}]}},{"name":"Pool","docs":["Market Maker Pool data."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"poolId","docs":["Unique Pool ID."],"type":"u64"},{"name":"quoteSignerPubKey","docs":["Public Key part of Secp256k1 quote signature scheme."],"type":{"array":["u8",64]}},{"name":"owner","docs":["Market Maker key that owns the Pool."],"type":"publicKey"}]}},{"name":"TradeReceipt","type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"txid","docs":["Unique Trade ID."],"type":{"array":["u8",32]}},{"name":"traderFrom","docs":["Trader that was debited the \\"From\\" token."],"type":"publicKey"},{"name":"traderTo","docs":["Trader that was credited the \\"To\\" token."],"type":"publicKey"},{"name":"tokenFromMint","docs":["\\"From\\" token mint."],"type":"publicKey"},{"name":"tokenToMint","docs":["\\"To\\" token mint."],"type":"publicKey"},{"name":"tokenFromAmount","docs":["\\"From\\" token amount."],"type":"u64"},{"name":"tokenToAmount","docs":["\\"To\\" token amount."],"type":"u64"},{"name":"pool","docs":["Pool that was traded against."],"type":"publicKey"},{"name":"poolId","docs":["Pool ID."],"type":"u64"}]}},{"name":"WormholeConfig","docs":["Main program configuration."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"wormholeChainId","docs":["Wormhole Chain ID."],"type":"u16"},{"name":"wormholeAddresses","docs":["Wormhole program\'s relevant addresses."],"type":{"defined":"WormholeAddresses"}},{"name":"wormholeBatchId","docs":["Wormhole nonce. Always 0. Storing it for completeness."],"type":"u32"},{"name":"wormholeFinality","docs":["Wormhole consistency level. u8 representation of Solana\'s","[Finality](wormhole_anchor_sdk::wormhole::Finality)."],"type":"u8"}]}},{"name":"WormholeEmitter","docs":["Wormhole emitter account for this chain.","This is the emitter of the Wormhole VAAs."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"}]}},{"name":"WormholeForeignEmitter","docs":["Wormhole emitter account for a foreign Hashflow chain."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"wormholeChainId","docs":["Wormhole Chain ID."],"type":"u16"},{"name":"emitterAddress","docs":["Emitter address on the foreign chain."],"type":{"array":["u8",32]}}]}},{"name":"HashflowChainMetadata","docs":["Stores Metadata for a Hashflow Chain.","Currently only the Wormhole Chain ID."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"wormholeChainId","docs":["Wormhole Chain ID."],"type":"u16"}]}},{"name":"WormholeChainMetadata","docs":["Stores Metadata for a Wormhole Chain.","Currently only the Hashflow Chain ID."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"hashflowChainId","docs":["Hashflow Chain ID."],"type":"u16"}]}},{"name":"XChainPoolAuthorization","docs":["Stores Pool authorization metadata between chains."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"pool","docs":["Pool pubkey on this chain."],"type":"publicKey"},{"name":"srcHashflowChainId","docs":["Hashflow Chain ID for foreign chain."],"type":"u16"},{"name":"srcPool","docs":["Pool address on foreign chain."],"type":{"array":["u8",32]}},{"name":"status","docs":["Authorization status."],"type":"bool"}]}},{"name":"OutboundXChainTradeReceipt","docs":["X-Chain Trade Metadata.","Used to send X-Chain trades via Wormhole."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"traderFrom","docs":["Account that transferred funds on this chain."],"type":"publicKey"},{"name":"pool","docs":["Pool that funds were transferred to."],"type":"publicKey"},{"name":"dstHashflowChainId","docs":["Hashflow chain ID of the foreign chain."],"type":"u16"},{"name":"dstPool","docs":["Pool address on the foreign chain."],"type":{"array":["u8",32]}},{"name":"dstExternalAccount","docs":["External account address on foreign chain, if applicable."],"type":{"array":["u8",32]}},{"name":"traderTo","docs":["Trader address to receive funds on foreign chain."],"type":{"array":["u8",32]}},{"name":"tokenFromMint","docs":["Mint of the \\"From\\" token."],"type":"publicKey"},{"name":"tokenToAddress","docs":["\\"To\\" token address on foreign chain."],"type":{"array":["u8",32]}},{"name":"tokenFromAmount","docs":["\\"From\\" token amount."],"type":"u64"},{"name":"tokenToAmount","docs":["\\"To\\" token amount to transfer. Little-Endian notation."],"type":{"array":["u8",32]}},{"name":"tokenFromTraderAccount","docs":["\\"From\\" token account of the trader."],"type":"publicKey"},{"name":"txid","docs":["Unique txid of the trade."],"type":{"array":["u8",32]}},{"name":"sent","docs":["Whether the trade has been sent."],"type":"bool"},{"name":"wormholeSequence","docs":["Wormhole sequence for sent trades."],"type":"u64"},{"name":"relayerFee","docs":["Fee paid to the relayer."],"type":"u64"}]}},{"name":"InboundXChainTradeReceipt","docs":["Receipt account for X-Chain trades."],"type":{"kind":"struct","fields":[{"name":"bump","docs":["PDA bump."],"type":"u8"},{"name":"batchId","docs":["AKA nonce. Should always be 0."],"type":"u32"},{"name":"wormholeMessageHash","docs":["Keccak256 hash of verified Wormhole message."],"type":{"array":["u8",32]}},{"name":"txid","docs":["Unique trade ID."],"type":{"array":["u8",32]}},{"name":"traderTo","docs":["Trader that received funds."],"type":"publicKey"},{"name":"tokenToMint","docs":["Mint for the \\"To\\" token."],"type":"publicKey"},{"name":"tokenToTraderAccount","docs":["Token Account for the \\"To\\" token."],"type":"publicKey"},{"name":"tokenToAmount","docs":["\\"To\\" token amount"],"type":"u64"},{"name":"pool","docs":["Pool that credits the trader."],"type":"publicKey"},{"name":"poolId","docs":["Pool ID."],"type":"u64"}]}}],"types":[{"name":"WormholeAddresses","docs":["Wormhole program related addresses."],"type":{"kind":"struct","fields":[{"name":"bridge","docs":["[BridgeData](wormhole_anchor_sdk::wormhole::BridgeData) address."],"type":"publicKey"},{"name":"feeCollector","docs":["[FeeCollector](wormhole_anchor_sdk::wormhole::FeeCollector) address."],"type":"publicKey"},{"name":"sequence","docs":["[SequenceTracker](wormhole_anchor_sdk::wormhole::SequenceTracker) address."],"type":"publicKey"}]}}],"errors":[{"code":6000,"name":"BumpNotFound","msg":"Bump not found"},{"code":6001,"name":"QuoteExpired","msg":"Quote has expired"},{"code":6002,"name":"InvalidSignature","msg":"Invalid Signature"},{"code":6003,"name":"CorruptSignature","msg":"Corrupt Signature"},{"code":6004,"name":"AmountTooHigh","msg":"Amount too high"},{"code":6005,"name":"AmountTooLow","msg":"Amount too low"},{"code":6006,"name":"InvalidHashflowChainId","msg":"Invalid Hashflow Chain ID"},{"code":6007,"name":"InvalidHashflowFeeCollector","msg":"Invalid Hashflow Fee Collector"},{"code":6008,"name":"UnauthorizedRelayer","msg":"Relayer Not Authorized"},{"code":6009,"name":"InvalidXChainTradeMessage","msg":"Invalid X-Chain Trade Message"},{"code":6010,"name":"InvalidDestinationPool","msg":"Invalid X-Chain Destination Pool"},{"code":6011,"name":"InvalidDestinationToken","msg":"Invalid X-Chain Destination Token Mint"},{"code":6012,"name":"XChainPoolNotAuthorized","msg":"X-Chain Pool Not Authorized"},{"code":6013,"name":"InvalidWormholeChainId","msg":"Invalid Wormhole Chain ID"},{"code":6014,"name":"InvalidWormholeBridge","msg":"Invalid Wormhole Bridge Config"},{"code":6015,"name":"InvalidWormholeFeeCollector","msg":"Invalid Wormhole Fee Collector"},{"code":6016,"name":"InvalidWormholeSequence","msg":"Invalid Wormhole Sequence"},{"code":6017,"name":"InvalidWormholeEmitter","msg":"Invalid Wormhole Emitter"},{"code":6018,"name":"InvalidWormholeForeignEmitter","msg":"Invalid Wormhole Foreign Emitter"},{"code":6019,"name":"WormholeMessageAlreadySent","msg":"Wormhole Message Already Sent"},{"code":6020,"name":"InvalidNativeMint","msg":"Invalid Native Mint Address"}]}')}}]);